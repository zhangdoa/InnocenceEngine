// shadertype=hlsl
#include "common/common.hlsl"

struct ComputeInputType
{
	uint3 groupID : SV_GroupID;           // 3D index of the thread group in the dispatch.
	uint3 groupThreadID : SV_GroupThreadID;     // 3D index of local thread ID in a thread group.
	uint3 dispatchThreadID : SV_DispatchThreadID;  // 3D index of global thread ID in the dispatch.
	uint  groupIndex : SV_GroupIndex;        // Flattened local index of the thread within a thread group.
};

#define RGB_TO_LUM float3(0.2125, 0.7154, 0.0721)

[[vk::binding(0, 0)]]
cbuffer PerFrameConstantBuffer : register(b0)
{
    PerFrame_CB g_Frame;
}

[[vk::binding(0, 1)]]
Texture2D<float4> in_luminance : register(t0);

[[vk::binding(0, 2)]]
RWStructuredBuffer<uint> out_histogram : register(u0);

groupshared uint histogramShared[256];

uint ComputeBinIndex(float3 colorHDR, float minLogLum, float inverseLogLumRange)
{
	float lum = dot(colorHDR, RGB_TO_LUM);

	if (lum < EPSILON)
	{
		return 0;
	}

	float logLum = saturate((log2(lum) - minLogLum) * inverseLogLumRange);

	return uint(logLum * 254.0 + 1.0);
}

[numthreads(16, 16, 1)]
void main(ComputeInputType input)
{
	histogramShared[input.groupIndex] = 0;
	GroupMemoryBarrierWithGroupSync();

	float2 l_DimensionFloat;
	float l_MipLevel;
	in_luminance.GetDimensions(0, l_DimensionFloat.x, l_DimensionFloat.y, l_MipLevel);

	uint2 l_Dimension = uint2(l_DimensionFloat);

	if (input.dispatchThreadID.x < l_Dimension.x && input.dispatchThreadID.y < l_Dimension.y)
	{
		float3 l_ColorHDR = in_luminance[int2(input.dispatchThreadID.xy)].xyz;
		uint l_BinIndex = ComputeBinIndex(l_ColorHDR, g_Frame.minLogLuminance, 1.0 / (g_Frame.maxLogLuminance - g_Frame.minLogLuminance));

		InterlockedAdd(histogramShared[l_BinIndex], 1);
	}

	GroupMemoryBarrierWithGroupSync();

	InterlockedAdd(out_histogram[input.groupIndex], histogramShared[input.groupIndex]);
}