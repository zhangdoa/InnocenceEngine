#version 450
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

struct DispatchParam
{
	uvec4 numThreadGroups;
	uvec4 numThreads;
};

struct Brick
{
	uint surfelRangeBegin;
	uint surfelRangeEnd;
};

layout(binding = 8, set = 0, std140) uniform dispatchParamsCBuffer
{
	DispatchParam dispatchParams[8];
} _26;

layout(binding = 11, set = 0, std140) uniform GISkyCBuffer
{
	layout(row_major) mat4 GISky_p_inv;
	layout(row_major) mat4 GISky_v_inv[6];
	vec4 GISky_probeCount;
	vec4 GISky_probeInterval;
	vec4 GISky_workload;
	vec4 GISky_irradianceVolumeOffset;
} _78;

layout(binding = 0, set = 1, std430) buffer in_bricks
{
	Brick _data[];
} in_bricks_1;

layout(binding = 1, set = 1, std430) buffer in_surfelIrradiance
{
	vec4 _data[];
} in_surfelIrradiance_1;

layout(binding = 2, set = 1, std430) buffer out_brickIrradiance
{
	vec4 _data[];
} out_brickIrradiance_1;

void main()
{
	if (((gl_GlobalInvocationID.x < _26.dispatchParams[3].numThreads.x) && (gl_GlobalInvocationID.y < _26.dispatchParams[3].numThreads.y)) && (gl_GlobalInvocationID.z < _26.dispatchParams[3].numThreads.z))
	{
		uint _271 = (gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * _26.dispatchParams[3].numThreads.x)) + ((gl_GlobalInvocationID.z * _26.dispatchParams[3].numThreads.x) * _26.dispatchParams[3].numThreads.y);
		if (float(_271) < _78.GISky_workload.y)
		{
			vec4 _358;
			if (in_bricks_1._data[_271].surfelRangeBegin != in_bricks_1._data[_271].surfelRangeEnd)
			{
				vec4 _357;
				_357 = vec4(0.0);
				for (uint _356 = in_bricks_1._data[_271].surfelRangeBegin; _356 <= in_bricks_1._data[_271].surfelRangeEnd; )
				{
					_357 += in_surfelIrradiance_1._data[_356];
					_356++;
					continue;
				}
				_358 = _357 / vec4(float((in_bricks_1._data[_271].surfelRangeEnd - in_bricks_1._data[_271].surfelRangeBegin) + 1u));
			}
			else
			{
				_358 = in_surfelIrradiance_1._data[in_bricks_1._data[_271].surfelRangeBegin];
			}
			out_brickIrradiance_1._data[_271] = _358;
		}
	}
}